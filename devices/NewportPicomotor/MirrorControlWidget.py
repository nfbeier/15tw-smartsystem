import numpy as np
from pylablib.devices import Newport
import sys, os
from PyQt5 import QtCore, QtGui, QtWidgets

cwd = os.getcwd()
print(cwd)
# Check if '15tw-smartsystem' is in the components
if '15tw-smartsystem' not in cwd.split(os.path.sep):
    raise ValueError("The directory does not contain '15tw-smartsystem' folder.")

# Rebuild the directory string up to and including '15tw-smartsystem', prevent import errors
cwd = os.path.sep.join(cwd.split(os.path.sep)[:cwd.split(os.path.sep).index('15tw-smartsystem') + 1])

sys.path.insert(0,cwd)

# setting the correct path
mirror_dir = os.path.dirname(os.path.abspath(__file__)) # current SingleMirror_GUI directory
parent_dir = os.path.dirname(mirror_dir) # get the parent directory of SingleMirror_GUI
sys.path.insert(0, parent_dir) 

from SingleMirror_GUI import Ui_Form  # Import the generated UI class

class MirrorControlWidget(QtWidgets.QWidget):
    '''
    A QWidget subclass for controlling a mirror using Newport Picomotor8742 stages.

    Attributes:
    stage : Newport.Picomotor8742()
        The Picomotor stage controller.
    xAxis : int
        The axis number for the x-axis control.
    yAxis : int
        The axis number for the y-axis control.
    mirror_label: str
        sets the label for the mirrors controlled by Newport Picomotor 8742 stages.
    ui : Ui_Form
        The user interface generated by PyQt5.

    Methods:
    movePico(axis, steps)
        Moves the specified axis by a user-defined number of steps.
    moveToHome()
        Moves both x and y axes to the home (0) position.
    updateConnectionStatus():
        Updates the connection status and LED indicator based on the number of connected stages.
    SafetySwitch():
        switch the safety mode on or off.
    isMirrorSafeToFire():
        Returns True if the mirror is safe to fire the laser (i.e not movable), False otherwise.
    updateMovementButtons():
        Updates the enabled state of movement buttons based on the safety mode.
    updateMirrorLockLabel():
        Updated the status of the safety switch based on the current safety mode

    '''

    Max_steps = 1000 # Maximum number of steps to prevent damage to the mirrors

    def __init__(self, stage, xAxis, yAxis, mirror_label, parent=None):
        '''
        Initializes the MirrorControlWidget with a given stage and axis configurations.

        Arguments:
        stage : Newport.Picomotor8742()
            The Picomotor stage controller.
        xAxis : int
            The axis number for the x-axis control.
        yAxis : int
            The axis number for the y-axis control.
        mirror_label : str
            The label for the mirror.
        parent : QWidget (optional)
            The parent widget (default is None).
        '''
        super(MirrorControlWidget, self).__init__(parent)

        # Error handling (Validate the x axis and y axis inputs)  
        if not isinstance(xAxis, int) or xAxis < 1 or xAxis > 4:
            raise ValueError("Axis number must be an odd positive integer, either 1 or 3.")
        if not isinstance(yAxis, int) or yAxis < 1 or yAxis > 4:
            raise ValueError("Axis number must be an even positive integer, either 2 or 4.")
        
        self.stage = stage
        self.xAxis = xAxis
        self.yAxis = yAxis
        self.mirror_safe = True # mirror is safe (i.e mirror motion is disabled) by default

        self.ui = Ui_Form()  # Create an instance of the generated UI class
        self.ui.setupUi(self)  # Set up the UI within this widget

        # Set the mirror label
        self.ui.Mirror_Label.setText(mirror_label)

        # Connect buttons to picomotor functions
        self.ui.ButtonLeft.clicked.connect(lambda: self.movePico(self.xAxis, -1 * self.ui.stepSize.value()))
        self.ui.ButtonRight.clicked.connect(lambda: self.movePico(self.xAxis, self.ui.stepSize.value()))
        self.ui.ButtonUp.clicked.connect(lambda: self.movePico(self.yAxis, self.ui.stepSize.value()))
        self.ui.ButtonDown.clicked.connect(lambda: self.movePico(self.yAxis, -1 * self.ui.stepSize.value()))
        self.ui.ButtonHome.clicked.connect(self.moveToHome)
        self.ui.ButtonSafety.clicked.connect(self.SafetySwitch)


    def movePico(self, axis, steps):
        '''
        Moves the specified axis by a given number of steps.

        Arguments:
        axis : int
            The axis to move (xAxis or yAxis).
        steps : int
            The number of steps to move the axis by.
        '''
        if self.stage:
            try:
                if axis not in [self.xAxis, self.yAxis]:
                    raise ValueError(f"Axis {axis} is not valid.")
                
                # Validate number of steps
                if not isinstance(steps, int) or steps > self.Max_steps:
                    raise ValueError(f"Number of steps {steps} is out of bounds. Maximum allowed steps: {self.Max_steps}.")


                if not self.isMirrorSafeToFire():
                    self.stage.move_by(axis=axis, steps=steps)
                    self.stage.wait_move()
                    if axis == self.xAxis:
                        self.ui.xStepNumber.display(self.stage.get_position(axis))
                    elif axis == self.yAxis:
                        self.ui.yStepNumber.display(self.stage.get_position(axis))
                else:
                    QtWidgets.QMessageBox.warning(self, "Safety Mode", "Mirror movement is disabled. Please enable to move the mirror.") 
            except ValueError as t:
                QtWidgets.QMessageBox.warning(self, "Input Error", str(t))
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "Error", f"Failed to move the Picomotor: {e}")

    def moveToHome(self):
        '''
        Moves both x and y axes to the home (0) position.
        '''
        if self.stage:
            try:
                if not self.isMirrorSafeToFire():
                    # Move x-axis to home
                    self.stage.move_to(axis=self.xAxis, position=0)
                    self.stage.wait_move()
                    # Move y-axis to home
                    self.stage.move_to(axis=self.yAxis, position=0)
                    self.stage.wait_move()
                    # Reset step counters
                    self.ui.xStepNumber.display(self.stage.get_position(self.xAxis))
                    self.ui.yStepNumber.display(self.stage.get_position(self.yAxis))
                else:
                    QtWidgets.QMessageBox.warning(self, "Safety Mode", "Mirror movement is disabled. Please enable to move the mirror.")
            except Exception as e:
                QtWidgets.QMessageBox.critical(self, "Error", f"Failed to move to Home: {e}")

        # Update connection status when initializing
        self.updateConnectionStatus()

    def updateConnectionStatus(self):
        '''
        Updates the connection status and LED indicator based on the number of connected stages.
        '''
        num_connected_stages = Newport.get_usb_devices_number_picomotor()
        self.ui.connectionStatusLabel.setText(f"Connected Controllers: {num_connected_stages}")

        if num_connected_stages >= 2:
            self.ui.LEDindicator.setStyleSheet("background-color: green; border-radius: 10px; min-width: 20px; min-height: 20px;")
        else:
            self.ui.LEDindicator.setStyleSheet("background-color: red; border-radius: 10px; min-width: 20px; min-height: 20px;")


        # Update movement button states based on initial safety status
        self.updateMovementButtons()

    def SafetySwitch(self):
        '''
        switch the safety mode on or off.
        '''
        self.mirror_safe = not self.mirror_safe
        self.updateMovementButtons()
        self.updateMirrorLockLabel()

    def isMirrorSafeToFire(self):
        '''
        Returns True if the mirror is safe to fire the laser (i.e not movable), False otherwise.
        '''
        return self.mirror_safe

    def updateMovementButtons(self):
        '''
        Updates the enabled state of movement buttons based on the safety mode.
        '''
        self.ui.ButtonLeft.setEnabled(not self.isMirrorSafeToFire())
        self.ui.ButtonRight.setEnabled(not self.isMirrorSafeToFire())
        self.ui.ButtonUp.setEnabled(not self.isMirrorSafeToFire())
        self.ui.ButtonDown.setEnabled(not self.isMirrorSafeToFire())

    def updateMirrorLockLabel(self):
        '''
        Updated the status of the safety switch based on the current safety mode
        '''
        if self.isMirrorSafeToFire():
            self.ui.MirrorLockLabel.setText("High Power Mode")
        else:
            self.ui.MirrorLockLabel.setText("Alignment Mode")

      